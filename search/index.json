[{"content":"2023.11.17 之前一直没怎么准备$NOIP$，也没有停课。今天晚修特意提前写完了作业到机房卷题找手感，一遍过掉了去年的第一题：\n信心++\n2023.11.18 早上起的有点早，有点困。\n8:30发了密码，先赶紧把文件夹建好了，检查了一波后开始看题。\n8:35想到了T1，飞快地打完了，结果最后一个大样例超时。\n8:50重新整理完思路，开始打T1的第二份代码。\n9:20打完并调完了T1，开始想T2。由于本来就没想过要切T2，于是就把每一种部分分都想了一下。\n9:50打完了60分的拼盘，剩下的情况感觉想不到了，果断跳题。\n然后就一直想不到。\n大约12:00时，打完了剩下两题暴力且没有思路，开始边检查T1、T2边想。\n突然发现T1有一个大样例没过，赶紧开始调，幸好最后过了。\n13:00，出考场了，此时估分：100+60+10+10=180\n下午去团建，爬山，累。\n2023.11.19 xtl神速出了估分：100+50+10+0=160\n洛谷：100+60+10+0=170\n接下来就等待按照惯例会一拖再拖的官方成绩。\n2023.11.20 数学周测150祭\n物理周测98寄\n出了$CSP$的奖项名单，拿下两个一等，虽然有所遗憾，但还是比较开心，算是弥补了去年没能拿到蓝勾的缺憾。\n一些想法 这次$NOIP$，毕竟也是第一次参加，赛前定的目标就是大概130左右就行了，最后估分能达到170也很惊喜，（似乎我校挺多人考炸？）\n似乎不太可能一等了，不过没关系，明年争取拿下一等。\n","date":"2023-11-20T00:00:00Z","permalink":"https://zswangziye.github.io/p/noip2023/","title":"NOIP2023游记"},{"content":"普及组 在考场上前两题很快就写出来了，测了一下样例没什么问题就暂时不管了。第三题是初中数学题+很多要求的输出，直接开始写，状态比较好不用怎么调就过了大样例。第四题刚开始看的时候没有什么思路，想的比较久，这时候本来是有点慌的，但是好在稳住了心态。最后还是想出了分层图最短路的办法，最后也过了大样例。写完四题之后就开始写对拍，但是只会写前两题的，测了很久也没什么问题。自测估分的时候本来感觉稳了，结果测出第四题超时，回家看了很久才发现问题：\n1 2 3 struct node{ LL x=1e12; }a[MAXN]; 考场代码就类似于上面这样，不知道为什么会超时，改成手动初始化就没问题了。\n普及组比赛暴露出来的问题主要是没有见过T4类似的题型，看来平时要多加练习，才能多了解些解题方法。\n至于让我超时的问题，感觉没什么办法避免，这次遇见了下次就知道了，上午的普及组还是很有价值的。\n赛时估分$400$。\n最后小图灵$380$、云斗$395$。\n官方得分$300$？？NOI LINUX2.0本地测试又能过？？？看来得申诉了。\n提高组 下午的状态比较一般，但还是很快打完了第一题，检查了一下就跳了。第二题一眼感觉可做，但是一直想不出来，想了很久打了个暴力就先不管了。看了T3、T4发现比T2难不少，于是又回头去想T2，但是还是想不到正解，比较慌，一直死磕到了比赛结束。\n看来还是积累不够多，同时也有思维上的问题，假期集训的时候要多加练习提升思维。\n赛时估分$150$。\n最后小图灵$150$、云斗$155$。\n官方成绩$150$，意料之中。\n总结 这次比赛的优点就是把自己会的分数基本都拿到了，没有非常离谱的失分，缺点首先是思维不够灵活，其次是代码能力不够导致提高T3没能打出部分分，在以后的训练中一定要改进。\n策略 首先是时间分配问题，S组4小时，4道题，题目由难到易分别最多分配30min、50min、50min、1h，剩下的50min中的30min检查，20min机动分配给上厕所等事情。 当然具体的时间分配要依据比赛实际情况以及自身实力调整，面对较难的比赛，一定要先打完暴力再冲正解。\n","date":"2023-10-30T00:00:00Z","permalink":"https://zswangziye.github.io/p/csp2023%E5%8F%8D%E6%80%9D/","title":"CSP2023反思"},{"content":"Day -6（3.4） 晚上打了场AtCoder，$rank 1515$，切了5题，信心++。\n打T5的时候心态不稳，没验证好复杂度就交了，错了7次，下次注意。\nDay -5（3.5） 早上8点多就回校了，假期减了一天。\n上午模拟赛，考得不好，pts和rk就不说了，信心\u0026ndash;。\n比赛补题地址\nT1 签到题，枚举两个相同字母的位置，计算把这两个字母之间其他的字母扔出去的交换代价，在交换代价合规情况下找最大可能的连续相同字母大小。\nT2 DP，分成五种情况讨论，$f[i][0]$表示当前位置为'0\u0026rsquo;，$f[i][1]$表示当前位置为\u0026rsquo;*\u0026rsquo;，$f[i][2]$表示当前位置为'2\u0026rsquo;，$f[i][3]$表示当前位置为'1\u0026rsquo;左边有地雷，$f[i][4]$表示当前位置为'1\u0026rsquo;右边有地雷。然后讨论各种情况的状态转移。\nT3 一种神奇的题目，先在原序列中把每个连续上升子串内部标记成同一编号，然后讨论几种可能的修改情况：1)在该子串前方或后方修改一个，使其长度+1。2)如果两个连续子串之间可以通过修改前一个子串合并，那就合并。3)修改后一个子串。\nT4 需要推一推，具体如下：\n首先求平均数在$[l,r]$等价于求平均数在$[1,l)$和$[1,r]$的数量，后者减去前者即为答案。\n以区间$[i,j]$的平均数为例，如果平均数需要满足这个性质，那么每个数减去$r$后求和的值必须$\\leq 0$。\n即为$a[i]-r+a[i+1]-r+……+a[i+j-1]-r \\leq 0$.\n设$b[i]=a[i]-r$，则$b[i]+b[i+1]+……+b[i+j-1] \\leq 0$.\n容易联想到前缀和，设$s[i]=\\Sigma_{j \\leq i} b[j]$，可得$s[i+k-1]-s[i-1] \\leq 0$，即$s[i+k-1] \\leq s[i-1]$.\n发现$i-1 \\leq i+k-1$，所以求逆序对。\nDay -4（3.6） 开始停课，第一次全天停。\n上午提高难度模拟赛，$160 pts$ $rank 1$，感觉良好，信心++。\n改题可以看DengDuck's blog\n比赛补题地址\nT1 官方题解：\n其实只需要简单地证明一下，分析几种情况：\n两个序列$1$的个数相同，但是顺序不同。例如：$101$和$110$。 最后一位不一样，而$1$的个数相同，这就意味着其他位置必定还有一个数位不同，所以对$2$取模为$0$。 两个序列$1$的个数不同，例如：$001$和$110$。 这时候我们去掉第二个数列的一个$1$，并把第一个数列该位置的数也去掉，就变为了上一种情况， 再加上一个不一样的，就变成了上一种情况，所以对$2$取模为$1$。 其他的可以以此类推扩展，具体看上面官方题解。 T2 官方题解：\n还有一个写的不错的题解：这里\n个人思路 这里的斜边其实都对应了两条直角边，所以只要枚举出两条直角边的长度（以下用$a$、$b$表示）就可以得出这条斜边的长度。\n再分析发现这条边上可供选择的点有$\\gcd(a,b)-1$个（可以使用相似三角形证明，题解中此处有误），而我们需要从中选择$n-2$个点（两个端点强制选），而相邻两个点的距离至少为$k$，所以得到$C_{g+1-2k-(n-3)(k-1)}^{n-2}$（在$n$个点中选出$m$个点，并且两个点之间间隔至少为$k$的方案数为$C_{n-(m-1)k}^{m}$）。\nT3 DengDuck的题解\n关于T4 它超纲了。\n期待周五ing。\nDay -3（3.7） 停课的第二天，还是提高难度模拟赛。\n本来：全部人$rank 5$，初二$rank 1$。\n因为计算错误和该死的Windows系统变成了：全部人$rank 9$，初二$rank 3$。\n信心\u0026ndash;。\nT1 期望简单题，可能需要点感性理解，继续挂上DengDuckの题解\nT2 其实是$3n+1$猜想（角谷猜想）的运用，知道了之后就简单多了，但是还要注意负数的情况。\nT3，T4 待学习。\n另外放上本地测试时遇到的神奇测试点：\n生地会考报名收走了身份证，这个问题不解决了有待解决。\nDay -2（3.8） 成功躲过了月考\n今日の教训：\n$$\r我们不是数学竞赛\\\\\r很多时候快速找到正解已经很不错了\\\\\r不一定需要证明\\\\\r打表都是可以的\\\\\r实在不行再跑一些暴力验证一下\\\\\r一定要灵活\\\\\r$$T1 一道简单$DP$，设$f[i][j][0/1]$表示前$i$个数里使用了$j$次修改，$0$表示当前不是山谷，$1$表示当前是山谷。\n如果当前本来是山谷，那么转移如下：\n$f[i][j][0]=f[i-1][j][1]$\n$f[i][j][1]=f[i-1][j][0]+a[i]$\n如果不是那么可以修改成山谷，转移如下：\n$f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])$\n$f[i][j][1]=f[i-1][j-1][0]+min(a[i-1],a[i+1])-1$\nT2 手推一下可以得到以下结论：\n当$n=3$时，答案为$a[1]-a[3]$。\n当$n=5$时，答案为$a[1]-2*a[3]+a[5]$。\n当$n=7$时，答案为$a[1]-3a[3]+3a[5]-a[7]$。\n可以发现奇数情况下，系数均与杨辉三角有关。\n如果直接$n^2$递推会超时，而杨辉三角又与组合数有关，所以可以通过公式法求解。\n偶数情况可以通过一次操作转化为奇数。\nT3、T4 待学习。\nDay -1（3.9） 复习了一整天，但是复习的东西好像都没用上……\nDay 0（3.10） 上午还是复习，下午三点坐车去广州，广州市区很堵，快五点才到酒店，然后去学校报到。\n晚上去看广州塔了，喝了教练请的饮料。\n复习了一会，又看了会电视就睡觉了。\nDay 1（3.11） 上午听讲座，讲了一些数据结构。\n下午比赛。\n先想了第一题，感觉还行，打了一下才发现不对劲，朴素做法时间会炸。\n想了一会没想到，就开了第二题，很快想到了宽搜，直接打了一份代码。\n开了第三题，感觉很难，打了个表就跳了。\n第四题也不会，打了个暴力，水20分。\n又回头看第一题，想到了和正解差不多的思路，但是没算好空间，以为开不下数组，最后打出来的代码挂了。\n晚上和$DeepSeaSpray$一起复习，和昨天一样看了会电视就睡觉了。\nDay 2（3.12） 上午听讲座，宣传了中大、学习到了乱搞思想。\n然后就是令人激动的滚榜环节，发现自己前两题都挂了。\nT1 T2 T3 T4 Total 估分 50 100 0 20 170 实际 30 80 0 20 130 差距有点大……压到了银牌线。\n下午Day2比赛。\n第一题看了一眼，直接切了。\n第二题打了个暴力水分。\n第三题还是不会。\n第四题没想清楚，赛场上以为很简单……\n吃完晚饭就回校了。\nDay 3（3.13） 晚上去看了分数。\nT1 T2 T3 T4 Total 估分 100 20 0 50 170 实际 100 20 0 30 150 还算不错，等排名，看看能不能保持住银牌。\n总结与反思 总分$280$，全省排名$54$，拿下银牌。\n下次要注意把问题分析清楚，还得计算好时间和空间复杂度，提升思维，争取更好的成绩。\n","date":"2023-03-06T00:00:00Z","permalink":"https://zswangziye.github.io/p/gdkoi2023%E6%99%AE%E5%8F%8A%E7%BB%84%E6%B8%B8%E8%AE%B0/","title":"GDKOI2023普及组游记"},{"content":"GDOI2022 普及组 游记 Day -4 突然被大宝叫走，很慌，结果是停课……\nDay -2 来了场模拟赛，第六名，初一第三，还不错。\nDay -1 依旧是模拟赛，考的一般。\nDay 0 上午依旧是上文化课，非常的不爽开心。 下午到机房，配置了一大堆东西，线上赛好麻烦。 配置完$ vscode $和录频软件，来了场打击信心赛。 拿了第七，竞赛班第一，初一第一，信心++。\nDay 1 精神状态一般，提前来机房复习了一波$ dij $、快速幂之类的算法基础。 $ 8:30 $，比赛终于开始了。\nT1 淼题，速切。\n预估：100，实际：100。\nT2 我居然没推出来？？？\n预估：???，实际：15。\nT3 想到一半，果断弃了去看T4。\n预估：???，实际：0。\nT4 好吧，我低估了$ GDOI $。\n预估：0，实际：0。\n总分爆炸，失误了，只有115…… 晚上宿舍只有我一个 （其实还有一堆蚊子），赶紧睡了。\nDay 2 早上被$ CCX $叫醒，一看手表，怎么$ 7:20 $了？！ 赶紧去食堂吃了早餐，到了机房。\nT1 一如既往的淼，切了。\n预估：100，实际：100。\nT2 乱搞了一下，测了下数据感觉只能过$ 40 $%，结果？！\n预估：40，实际：100？！\nT3 大模拟！！！写了四十分钟左右，赛时自我感觉$ AC $，样例过了，最大的数据也没超时。\n预估：100，实际：40？？？\nT4 一如既往的放弃水分。\n总分240，还行。 总结 Day 1：全省$ No.496 $\nDay 2：全省$ No.135 $\nTotal：全省$ No.283 $\n明年加油吧……\n","date":"2022-04-19T00:00:00Z","permalink":"https://zswangziye.github.io/p/gdoi2022%E6%99%AE%E5%8F%8A%E7%BB%84%E6%B8%B8%E8%AE%B0/","title":"GDOI2022普及组游记"},{"content":"NOI Online 2022 入门组总结 T1 王国比赛 民间数据：100 pts 官方数据：100 pts 【思路】 赛时思路：先根据大臣的答案统计每一道题的预测答案，然后再把预测的答案和真正的答案比较。 正解：同上。 【情况】 这道题不用太多思考，看懂题就行，考试的时候正常发挥，快速打完了。\nT2 数学游戏 民间数据：40 pts 官方数据：70 pts 【思路】 赛时思路： $$\rz=x*y*gcd(x,y)\r$$$$\rz/x=y*gcd(x,y)\r$$$$\r这也就意味着我们只需要枚举y和gcd(x,y)其中之一即可求出另外一个。\r$$$$\r那枚举哪个更好？想一想，gcd(x,y)肯定要比y小，于是枚举gcd(x,y)是最好的选择。\r$$然后就动手敲代码……经过对拍测试，这份代码总的来说速度不错，但是不能A。\n正解： $$\r设d=gcd(x,y),x=pd,y=qd,z=pqd^3.\r$$$$\r由gcd定义得:p与q互质.\r$$$$\r∴p^2与q互质.\r$$$$\r现在已知pd与pqd^3也就是x和z,需要求出y=qd.\r$$$$\rqd=pqd^3/pd/d，于是我们只需要求出d.\r$$$$\r运用p^2与q互质的性质，可以构造出d^2=gcd(p^2d^2,qd^2)=gcd(x^2,z/x).\r$$$$\r则d=sqrt(gcd(x^2,z/x)),最后需要判断是否合法.\r$$【情况】 做的时候推不出正解，只能尽可能的减小时间复杂度，拿了70分，不大满意，下次恶补下数学。\nT3 字符串 民间数据：30 pts 官方数据：30 pts 【思路】 赛时思路： 我能想到的只有三个字母： $$\rDFS\r$$ 时间复杂度不用算都知道会爆炸……\n正解： 待学习……\n总结 T1 国王比赛 T2 数学游戏 T3 字符串 总分 洛谷自测成绩 100 40 30 170 官方公布成绩 100 70 30 200 怎么……官方数据比民间数据还水……\n总的来说，考的比较满意。\n","date":"2022-03-31T00:00:00Z","permalink":"https://zswangziye.github.io/p/noi-online-2022-%E5%85%A5%E9%97%A8%E7%BB%84%E6%80%BB%E7%BB%93/","title":"NOI Online 2022 入门组总结"},{"content":"这次考试心态还可以，但是四道题只对了一道，两道超时，一道答案错误。做得不好，没有达到预期。除了第三题之外，其他题对拍全过，时间复杂度太高。\n洛谷自测分数 分糖果 插入排序 网络连接 小熊的果篮 总分 AC 100 TLE 72 WA 25 TLE 70 267 1.分糖果 这道题做的还不错，想的时候没有花太多时间。\nL和R数据范围达到了恐怖的$10^9$，很明显不能暴力，只能考虑$O(1)$。 首先求出一个数$t$，$t$是$R$左边的第一个满足$t$ $mod$ $n=n-1$的数。 然后再判断，这个$t$在不在$L$到$R$的区间内。 如果在，答案为$t$ $mod$ $n$。 如果不在，可以证明，答案为$R$ $mod$ $n$。\n考场代码（AC代码） 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,l,r; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;l,\u0026amp;r); int t=(n-1-l%n)+l; if(t\u0026lt;=r){ printf(\u0026#34;%d\u0026#34;,t%n); }else{ printf(\u0026#34;%d\u0026#34;,r%n); } } 2.插入排序 考场上找出规律：可以用结构体+sort，先按照数值排序，数值相同的情况下按编号排序，于是就有了考场上$O(1)$修改的代码。 但是我忽略了一点，修改次数不超过5000，然后就悲剧了…… 下次一定要认真审题，不要忽略题目给你的任何一点提示或要求。\n考场代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,q; struct node{ int x,y; bool operator \u0026lt;(const node \u0026amp;t)const{ return x\u0026lt;t.x||(x==t.x\u0026amp;\u0026amp;y\u0026lt;t.y); } }b[8001]; int a[8001]; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;q); for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i=1;i\u0026lt;=q;i++){ //\tmemset(b,0,sizeof(b)); //\tmemset(num,0,sizeof(num)); int t,x,y; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); if(t==1){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); a[x]=y; } if(t==2){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); for(int j=1;j\u0026lt;=n;j++){ b[j].x=a[j]; b[j].y=j; } sort(b+1,b+n+1); for(int j=1;j\u0026lt;=n;j++){ if(b[j].y==x){ printf(\u0026#34;%d\\n\u0026#34;,j); } } } } } 【正解】 既然题目说了，排序不产生影响，那么我们不必在数组中进行排序，可以用$vector$。 其次，每次只修改一个数，也就意味着之前的排序结果可以重用，从而降低时间复杂度。 对于每一次修改，我们只需要：\n在$vector$中找到并删除这个数 往$vector$中推入一个新的数，并维护数列单调性。 但是，这个数列是单调递增的，于是可以使用二分来降低时间复杂度。 于是就有了优秀的$O(nlogn)$的AC代码： AC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //参考网址：https://www.cnblogs.com/chy12321/p/15456919.html#%E9%A2%98%E8%A7%A3 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,q; struct node{ int v,id; bool operator \u0026lt;(const node \u0026amp;t)const{ return v\u0026lt;t.v||(v==t.v\u0026amp;\u0026amp;id\u0026lt;t.id); } }a[8001]; vector\u0026lt;node\u0026gt; f; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;q); for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i].v); a[i].id=i; f.insert(lower_bound(f.begin(),f.end(),a[i]),a[i]); } int tt,x,v; for(int i=1;i\u0026lt;=q;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;tt); if(tt==1){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;v); f.erase(lower_bound(f.begin(),f.end(),a[x])); a[x].v=v; f.insert(lower_bound(f.begin(),f.end(),a[x]),a[x]); }else{ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); printf(\u0026#34;%d\\n\u0026#34;,lower_bound(f.begin(),f.end(),a[x])-f.begin()+1); } } } 网络连接 赤裸裸的大模拟，码农题，思路、判断什么的看题就行。 考场上一次性打完了，样例只有一个没过，实在调不出来了。\n考场代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int a[101],nf,nk,b[101]; int vis[2001][101],vis1[2001][101],fuwu[2001]; bool check(int x,int y,int z,int k,int w,char a1,char a2,char a3,char a4){ if(a1==\u0026#39;.\u0026#39;\u0026amp;\u0026amp;a2==\u0026#39;.\u0026#39;\u0026amp;\u0026amp;a3==\u0026#39;.\u0026#39;\u0026amp;\u0026amp;a4==\u0026#39;:\u0026#39;\u0026amp;\u0026amp;x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;=255\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;=255\u0026amp;\u0026amp;z\u0026gt;=0\u0026amp;\u0026amp;z\u0026lt;=255\u0026amp;\u0026amp;k\u0026gt;=0\u0026amp;\u0026amp;k\u0026lt;=255\u0026amp;\u0026amp;w\u0026gt;=0\u0026amp;\u0026amp;w\u0026lt;=65535){ return true; } return false; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ memset(a,0,sizeof(a)); char t; bool flag1=true; while(1){ t=getchar(); if(t==\u0026#39;S\u0026#39;){ flag1=true; break; } if(t==\u0026#39;C\u0026#39;){ flag1=false; break; } } bool flag2=false,flag3=false; int x=0,cnt=0,cnt1=0; while(1){ if(t==\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;flag3==false){ flag3=true; } if(flag3==true\u0026amp;\u0026amp;t==\u0026#39;\\n\u0026#39;){ break; } t=getchar(); if(t\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;t\u0026lt;=\u0026#39;9\u0026#39;){ flag2=true; } if(flag2){ if(t\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;t\u0026lt;=\u0026#39;9\u0026#39;){ x=x*10+(int)(t-\u0026#39;0\u0026#39;); }else{ b[++cnt1]=t; flag2=false; a[++cnt]=x; x=0; } } } if(!check(a[1],a[2],a[3],a[4],a[5],b[1],b[2],b[3],b[4])){ printf(\u0026#34;ERR\\n\u0026#34;); }else{ if(flag1){ bool flag4=true; for(int j=1;j\u0026lt;=nf;j++){ int sum=0; for(int k=1;k\u0026lt;=5;k++){ if(vis[j][k]==a[k]){ sum++; } } if(sum==5){ flag4=false; break; } } if(!flag4){ printf(\u0026#34;FAIL\\n\u0026#34;); }else{ printf(\u0026#34;OK\\n\u0026#34;); nf++; for(int j=1;j\u0026lt;=5;j++){ vis[nf][j]=a[j]; } } }else{ bool flag4=true; int tt; for(int j=1;j\u0026lt;=nf;j++){ int sum=0; for(int k=1;k\u0026lt;=5;k++){ if(vis[j][k]==a[k]){ sum++; } } if(sum==5){ flag4=false; tt=j; break; } } if(flag4){ printf(\u0026#34;FAIL\\n\u0026#34;); }else{ bool flag5=true; int pp; for(int j=1;j\u0026lt;=nk;j++){ int sum=0; for(int k=1;k\u0026lt;=5;k++){ if(vis1[j][k]==a[k]){ sum++; } } if(sum==5){ flag5=false; pp=j; break; } } if(!flag5){ printf(\u0026#34;%d\\n\u0026#34;,fuwu[pp]); }else{ nk++; fuwu[nk]=tt; printf(\u0026#34;%d\\n\u0026#34;,tt); } } } } } } 至今仍未AC……\n小熊的果篮 考试时的想法就是直接模拟，输出过的就标记。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int a[200001]; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int la=-1,n1=n; for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); if(la!=a[i]){ la=a[i]; printf(\u0026#34;%d \u0026#34;,i); a[i]=2; n1--; } } printf(\u0026#34;\\n\u0026#34;); while(n1\u0026gt;0){ la=-1; bool flag=false; for(int i=1;i\u0026lt;=n;i++){ if(a[i]==2)continue; if(la!=a[i]){ la=a[i]; printf(\u0026#34;%d \u0026#34;,i); flag=true; a[i]=2; n1--; } } if(flag)printf(\u0026#34;\\n\u0026#34;); } } 这样写肯定超时，目前还未AC。\n总结一下 这次考试后三道题某谷给出的标签都是模拟，暴力，第一题是数学，数论。 三道模拟题写挂，很不应该，应该好好反思，为什么没有优化时间复杂度？第三题这种码农题练得也不多，总的来说情况不好，下次加油。\n网上发现两个题解，可以参考参考： 第一个 第二个\n","date":"2021-10-26T00:00:00Z","permalink":"https://zswangziye.github.io/p/csp-j2021%E6%80%BB%E7%BB%93/","title":"CSP-J2021总结"}]